<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>clout2</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      text-align: center;
      background-color: black;
    }

    canvas {
      position: relative;
      margin: 0 auto;
      margin-top: calc(50% - 92.5px);
      /* width:100vw;
      height:100vh; */
    }
  </style>
</head>

<body>
  <div id="app"></div>
  <!-- built files will be auto injected -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.0.1/TweenLite.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.0.1/TweenMax.min.js"></script>
  <script src="tween.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.7.1/pixi.min.js"></script>
</body>

</html>


<script>
  function random(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive
  }


  window.addEventListener('keydown', function(event) {
    switch (event.keyCode) {
      case 37: //Left
        GameStage.person.moveLeft();
        //  mainCharacter.moveLeft();
        break;
      case 38: //up
        GameStage.person.moveUp();
        //  mainCharacter.moveUp();
        break;
      case 39: //Right
        GameStage.person.moveRight();
        //  mainCharacter.moveRight();
        break;
      case 40: //Down. TODO : Confirm
        GameStage.person.moveDown();
        //  mainCharacter.moveDown();
        break;
      case 16: // Shift (duck)
        GameStage.person.duck();
        break;
      case 32:
        GameStage.person.jump();
        //mainCharacter.duck();
    }
  });
  window.addEventListener('keyup', function(event) {
    switch (event.keyCode) {
      case 16:
        GameStage.person.stan();
        break;
      case 32:
        GameStage.person.stan();
        // mainCharacter.stan();
    }
  });

  //BULLETS
  class Bullets {

    constructor(game) {
      this._game = game;
      this._isDestroyed = false;
      this._speed = 0;
      this._first;
      this._landingPositions = [35, 65, 110];
      this._addSpriteBody = function(spriteNumber) {
        var bulletImage = 'bullet' + spriteNumber + '.png';
        this._body = PIXI.Sprite.fromImage(bulletImage);
      }
      this._stagger = function() {
        return random(0, -200)
      }
      this.render = function(randomX) {
        //if (GameStage.bulletArray.length < 6) {
        let numberOfBullets = 3,
          spacing = 48,
          xOffset = this._game.renderer.width / 2,
          speed = 2,
          direction = 1;
        //let x = spacing * i + xOffset;
        let x = spacing + xOffset;
        let bullet = new PIXI.Container();

        let y = this._stagger();
        let spriteNumber = random(1, 4);
        let landingRandom = random(0, 3);
        this._addSpriteBody(spriteNumber);

        bullet.addChild(this._body);
        // console.log(landingRandom);
        bullet._landingPos = this._landingPositions[landingRandom];
        bullet.position.x = randomX;
        bullet.position.y = y;
        bullet.vy = speed * direction;
        bullet.rotated = false;
        direction *= -1;
        this._game.stage.addChild(bullet);
        this._game.bulletArray.push(bullet);
      }
      this.remove = function(bullet) {
        var index = GameStage.bulletArray.indexOf(bullet);
        if (index > -1) {
          GameStage.bulletArray.splice(index, 1);
        }
        GameStage.stage.removeChild(bullet);
        //GameStage.bulletArray.shift();
      }

      this.rain = function() {

        GameStage.bulletArray.forEach(function(bullet) {
          if ((bullet.position.y < GameStage.renderer.height) && bullet.position.y >= (GameStage.renderer.height - bullet._landingPos)) {
            // var currentFrame =
            var switchInterval = Math.round(random(2, 2000));
            var frameCount = Math.round(GameStage._lastFrameTime);
            bullet.position.y = bullet.position.y;
            if (bullet.rotated !== true) {
              new Tween(bullet, "rotation", -0.2, 10, true);
              //bullet.rotation -= 0.2;
              bullet.rotated = true;
            }

            if (frameCount % switchInterval == 0) {
              GameStage.Bullets.remove(bullet);
              GameStage.addBullets();
            }

            // (93, 98.5) is center of center bunny sprite in local container coordinates
            // we want it to be in (200, 150) of global coords
            // bullet.pivot.x = 80 + 26 * 0.5;
            // bullet.pivot.y = 80 + 37 * 0.5;
            //  bullet.style.transform = "rotate3d(2, -1, -1, -0.2turn)";
            // if (frameCount % switchInterval == 0) {

          } else if (bullet.position.y > GameStage.renderer.height) {
            GameStage.Bullets.remove(bullet);
            GameStage.addBullets();
          } else {
            bullet.position.y += 1
          }
          //  bullet.position.y = (bullet.position.y > GameStage.renderer.height) ? 0 : bullet.position.y += 1;
        });
      }

      this.testCollision = function() {
        //console.log(GameStage.person);
        GameStage.bulletArray.forEach(function(bullet) {
          if (hitTestRectangle(bullet, GameStage.person._container)) {
            //There's a collision
            console.log('collision');
            if (GameStage.state._state !== "load") {
              GameStage.state.updateInternal();
              //  GameStage.state.add("load", loadState);
            }
            //GameStage.Bullets.remove();
            //GameStage.person.remove();
          } else {
            //There's no collision
            //console.log('no collision');
          }
        });
      }
    }
    // remove () {
    //   this._game.stage.removeChild(this._container.);
    // }
  }

  //  Loader
  class Loader {
    constructor() {
      this._callback = null;
      this._assetLoader = new PIXI.loaders.Loader();
      this._assetLoader.add('Character_Duck.png');
      this._assetLoader.add('Character_Standing.png');
      this._assetLoader.add('Character_Jump.png');
      this._assetLoader.add('Landscape.png');
      this._assetLoader.add('bullet1.png');
      this._assetLoader.add('bullet2.png');
      this._assetLoader.add('bullet3.png');
      this._assetLoader.once('complete', this._onImagesLoaded.bind(this));
    }
    load(callback) {
      this._callback = callback;
      this._assetLoader.load();
    }

    _onImagesLoaded() {
      this._callback();
    }
  }


  //  PERSON
  class Person {
    constructor(game, x, y) {
      this._game = game;
      this._isDestroyed = false;
      this._speed = 0;
      //this._health = MAX_HEALTH;
      this._container = new PIXI.Container();
      this._container.position.x = x;
      this._container.position.y = y;
      this._body = PIXI.Sprite.fromImage('Character_Standing.png');
      // this._container.width = this._body.width;
      this._body.anchor.x = 0.5;
      this._body.anchor.y = -0.25;
      this._body.scale.x = 1;
      this._body.scale.y = 1;
      this._container.addChild(this._body);
      this._game.stage.addChild(this._container);

      this._container.width = this._body.width;
      this._container.height = this._body.height;

      this._originalY = this._container.position.y;
      //console.log(this.);
      // this._intersects = function(other) {
      //   var d = dist(this.x, this.y, other.x, other.y);
      //   if (d < this.r + other.r) {
      //     return true
      //   } else {
      //     return false
      //   }
      // }
    }
    moveLeft() {
      var dtLeftX = this._container.position.x;
      var newSpot = (dtLeftX - 45);
      var maxLeftX = (GameStage.renderer.width / 2) - 150;
      var playerHalfWidth = this._body.width / 2;

      if (newSpot <= maxLeftX) {
        var newmaxLeft = maxLeftX + playerHalfWidth;
        new Tween(this, "_container.position.x", newmaxLeft, 10, true);
      } else {
        new Tween(this, "_container.position.x", newSpot, 10, true);
      }
    }
    moveRight() {
      var dtLeftX = this._container.position.x;
      var newSpot = (dtLeftX + 45);
      var maxLeftX = (GameStage.renderer.width / 2) + 150;
      var playerHalfWidth = this._body.width / 2;

      if (newSpot >= maxLeftX) {
        var newmaxLeft = maxLeftX - playerHalfWidth;
        new Tween(this, "_container.position.x", newmaxLeft, 10, true);
      } else {
        new Tween(this, "_container.position.x", newSpot, 10, true);
      }
    }
    moveUp() {
      var dtLeftY = this._container.position.y;
      var newSpot = (dtLeftY - 25);
      new Tween(this, "_container.position.y", this._originalY, 10, true);
    }
    moveDown() {
      var dtLeftY = this._container.position.y;
      var newSpot = (dtLeftY + 25);
      var orig = (this._originalY + 25);
      new Tween(this, "_container.position.y", orig, 10, true);
    }
    stan() {
      this._container.removeChild(this._body);
      this._body = PIXI.Sprite.fromImage('Character_Standing.png');
      this._body.anchor.x = 0.5;
      this._body.anchor.y = -0.25;
      this._container.addChild(this._body);
    }
    duck() {
      this._container.removeChild(this._body);
      this._body = PIXI.Sprite.fromImage('Character_Duck.png');
      this._body.anchor.x = 0.5;
      this._body.anchor.y = -0.45;
      this._container.addChild(this._body);
    }
    jump() {
      this._container.removeChild(this._body);
      this._body = PIXI.Sprite.fromImage('Character_Jump.png');
      this._body.anchor.x = 0.5;
      this._body.anchor.y = 0.25;
      this._container.addChild(this._body);
    }
    // checkHit(bulletPosition) {
    //   if (this._body.containsPoint(bulletPosition)) {
    //     return true;
    //   }
    //   return false
    // }
    remove() {
      this._game.stage.removeChild(this._container);
    }
  }


  //GAME
  //
  //class Game extends EventEmitter{
  class Game {
    constructor(element) {
      //super();
      this._element = element;
      this.person = null;
      this.stage = new PIXI.Container();
      this.renderer = PIXI.autoDetectRenderer(300, 185);
      this._element.appendChild(this.renderer.view);
      this._lastFrameTime = 0;
      this.bulletArray = [];
      this.state = "";
      requestAnimationFrame(this._tick.bind(this));
    }
    addBg() {
      var bg = new PIXI.Sprite.fromImage('Landscape.png');
      bg.anchor.set(0.5);
      bg.position.set(GameStage.renderer.view.width / 2, GameStage.renderer.view.height / 2);
      bg.scale.x = 1;
      bg.scale.y = 1;
      this.stage.addChild(bg);
    }
    addBullets() {
      var x = 0;
      var y = 0;
      var numberOfBullets = 3;
      for (let i = 0; i < numberOfBullets; i++) {
        if (GameStage.bulletArray.length < 3) {
          var randomX = random(0, GameStage.renderer.width);
          this.Bullets = new Bullets(this);
          this.Bullets.render(randomX);
        }
      }
    }
    addPerson() {
      //Comment back in for random positioning
      // var x = this.renderer.width * (0.1 + Math.random() * 0.8);
      // var y = this.renderer.height *(0.1 * Math.random() * 0.8);
      let x = GameStage.renderer.width / 2;
      let y = GameStage.renderer.height / 2;
      this.person = new Person(this, x, y);
    }
    addState() {
      this.state = new State(this);
    }

    removePlayer() {
      this.person = null
    }

    _tick(currentTime) {
      //this.emit('update', currentTime - this._lastFrameTime, currentTime);
      this._lastFrameTime = currentTime;
      this.renderer.render(this.stage);
      Tween.runTweens();
      requestAnimationFrame(this._tick.bind(this));
      this.Bullets.rain();
      this.Bullets.testCollision();
    }
  }

  //  STATES
  var bootState = {
    create: function() {
      //add sprites/containers
      console.log('bootstate creating');
    },
    //automatic
    preload: function() {
      //load imags
      // _header: "bootstate header",
      console.log('bootstate preloading');
      GameStage.addBg();
      GameStage.addPerson();
      GameStage.addBullets();
    },
    update: function() {
      console.log('bootstate updating');
      GameStage.state.add("load", loadState);

      //game.state.add(load, loadState);
    }
  }
  var loadState = {
    preload: function() {
      //load imags
      // _header: "bootstate header",
      //if (GameStage.state._state !== "load")
      console.log('LOADING prelod()');
    },
    update: function() {
      console.log('LOADING update()');
    }
    // create: function () {
    //   //add sprites/containers
    //   console.log('creating');
    // },
    // update: function () {
    //   console.log('updating');
    //   //GameStage.state.add(load, loadState);
    //     //game.state.add(load, loadState);
    // }
    //var loadingLabel = "";
    //GameStage.load.image();
    //automatic
    //GameStage.state.add(menu, menuState);
  }
  var looseState = {

  }
  var menuState = {
    //var menuLabel = "";
    //name input ?
    //TODO: wrap in event listener
    //GameStage.state.add(play, playState);
  }
  var winState = {
    //TODO: wrap in event listener
    //GameStage.state.add(menu, menuSate);
  }

  //  GAME State
  class State {
    constructor(game) {
      this._game = game;
      this._state = "";
      this._stateObj = {};
    }
    preload() {
      //this._game.stateObj.preload();
      GameStage.state._stateObj.preload();
      // GameStage.state.stateObj.update();
    }
    create() {
      //this._game.stateObj.preload();
      GameStage.state._stateObj.create();
      // GameStage.state.stateObj.update();
    }
    add(state, stateObj) {
      this._state = state;
      this._stateObj = stateObj;
      this.preload();
    }
    updateInternal() {
      GameStage.state._stateObj.update();
    }
  }



  //HELPER COLLISION DETECTION FUNCTION
  function hitTestRectangle(r1, r2) {

    //Define the variables we'll need to calculate
    let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

    //hit will determine whether there's a collision
    hit = false;
    //Find the center points of each sprite
    r1.centerX = r1.x + r1.width / 2;
    r1.centerY = r1.y + r1.height / 2;
    r2.centerX = r2.x + r2.width / 2;
    r2.centerY = r2.y + r2.height / 2;

    //console.log(r2);

    //Find the half-widths and half-heights of each sprite
    r1.halfWidth = r1.width / 2;
    r1.halfHeight = r1.height / 2;
    r2.halfWidth = r2.width / 2;
    r2.halfHeight = r2.height / 2;

    //Calculate the distance vector between the sprites
    vx = r1.centerX - r2.centerX;
    vy = r1.centerY - r2.centerY;

    //Figure out the combined half-widths and half-heights
    combinedHalfWidths = r1.halfWidth + r2.halfWidth;
    combinedHalfHeights = r1.halfHeight + r2.halfHeight;

    //Check for a collision on the x axis
    if (Math.abs(vx) < combinedHalfWidths) {

      //A collision might be occuring. Check for a collision on the y axis
      if (Math.abs(vy) < combinedHalfHeights) {

        //There's definitely a collision happening
        hit = true;
      } else {

        //There's no collision on the y axis
        hit = false;
      }
    } else {

      //There's no collision on the x axis
      hit = false;
    }

    //`hit` will be either `true` or `false`
    return hit;
  };

  //INIT
  let GameStage = new Game(document.body);
  GameStage.addState();
  GameStage.state.add("boot", bootState);

</script>
