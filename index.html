<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>clout2</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      text-align: center;
      background-color: black;
    }

    canvas {
      position: relative;
      margin: 0 auto;
      margin-top: calc(50vh - 92.5px);
      /* width:100vw;
      height:100vh; */
    }
  </style>
</head>

<body>
  <div id="app"></div>
  <!-- built files will be auto injected -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.0.1/TweenLite.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.0.1/TweenMax.min.js"></script>
  <script src="tween.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.7.1/pixi.min.js"></script>
</body>

</html>


<script>
  function random(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive
  }


  window.addEventListener('keydown', function(event) {
    switch (event.keyCode) {
      case 37: //Left
        GameStage.person.moveLeft();
        //  mainCharacter.moveLeft();
        break;
      case 38: //up
        GameStage.person.moveUp();
        //  mainCharacter.moveUp();
        break;
      case 39: //Right
        GameStage.person.moveRight();
        //  mainCharacter.moveRight();
        break;
      case 40: //Down. TODO : Confirm
        GameStage.person.moveDown();
        //  mainCharacter.moveDown();
        break;
      case 16: // Shift (duck)
        GameStage.person.duck();
        break;
      case 32:
        GameStage.person.jump();
        //mainCharacter.duck();
    }
  });
  window.addEventListener('keyup', function(event) {
    switch (event.keyCode) {
      case 16:
        GameStage.person.stan();
        break;
      case 32:
        GameStage.person.stan();
        // mainCharacter.stan();
    }
  });

  //BULLETS
  class Bullets {

    constructor(game) {
      this.game = game;
      this.isDestroyed = false;
      this.speed = 0;
      this.landingPositions = [35, 65, 110];
      this.body = null;
      this.spriteNumber = random(1, 4);
      this.landingRandom = random(0,3);
      this.randomX = random(0, GameStage.renderer.width);
    }
      render() {
        let numberOfBullets = 3,
          spacing = 48,
          xOffset = this.game.renderer.width / 2,
          speed = 2,
          direction = 1;
        let x = spacing + xOffset;
        let bullet = new PIXI.Container();
        let y = random(0, -200);

        var bulletImage = 'bullet' + this.spriteNumber + '.gif';
        this.body = PIXI.Sprite.fromImage(bulletImage);
        this.body.scale.x = 0.2;
        this.body.scale.y = 0.2;

        bullet.addChild(this.body);
        bullet.landingPos = this.landingPositions[this.landingRandom];
        bullet.position.x = this.randomX;
        bullet.position.y = y;
        bullet.vy = speed * direction;
        bullet.rotated = false;
        bullet.isBaddie = this.spriteNumber >= 3 ? true : false;
        bullet.isGoodie = this.spriteNumber <= 2 ? true : false;
        direction *= -1;

        this.game.stage.addChild(bullet);
        this.game.bulletArray.push(bullet);
      }
      remove(bullet) {
        var index = GameStage.bulletArray.indexOf(bullet);
        if (index > -1) {
          GameStage.bulletArray.splice(index, 1);
        }
        GameStage.stage.removeChild(bullet);
      }
      rain() {
        GameStage.bulletArray.forEach(function(bullet) {
          if ((bullet.position.y < GameStage.renderer.height) && bullet.position.y >= (GameStage.renderer.height - bullet.landingPos)) {
            var switchInterval = Math.round(random(2, 2000));
            var frameCount = Math.round(GameStage._lastFrameTime);
            //  new Tween(bullet, "rotation", -0.2, 10, true);
            if (frameCount % switchInterval == 0) {
              GameStage.Bullets.remove(bullet);
              GameStage.addBullets();
            }
          } else if (bullet.position.y > GameStage.renderer.height) {
            GameStage.Bullets.remove(bullet);
            GameStage.addBullets();
          } else {
            bullet.position.y += 1
          }
        });
      }
      testCollision() {
        GameStage.bulletArray.forEach(function(bullet) {
          if ( GameStage.state.state !== "load") {
          //  console.log(bullet);
            if (hitTestRectangle(bullet, GameStage.person._container)){
              if (bullet.isBaddie == true) {
                console.log('baddie');
                //clout goes down
                GameStage.hitPoints--;
              } else {
                console.log('goodie');
                //clout goes up
                GameStage.hitPoints++;
              }
              GameStage.state._stateObj.update();
              GameStage.Bullets.remove(bullet);
              GameStage.addBullets();
            }
          }
        });
      }
    }

  //  PERSON
  class Person {
    constructor(game, x, y) {
      this._game = game;
      this._isDestroyed = false;
      this._speed = 0;
      this._container = new PIXI.Container();
      this._container.position.x = x;
      this._container.position.y = y;
      this._body = PIXI.Sprite.fromImage('Character_Standing.png');
      this._body.scale.x = 1;
      this._body.scale.y = 1;
      this._container.addChild(this._body);
      this._game.stage.addChild(this._container);
      this._container.width = this._body.width;
      this._container.height = this._body.height;
      this._originalY = this._container.position.y;
    }
    moveLeft() {
      var dtLeftX = this._container.position.x;
      var newSpot = (dtLeftX - 45);
      var maxLeftX = (GameStage.renderer.width / 2) - 150;
      var playerHalfWidth = this._body.width / 2;

      if (newSpot <= maxLeftX) {
        var newmaxLeft = maxLeftX + playerHalfWidth;
        new Tween(this, "_container.position.x", newmaxLeft, 10, true);
      } else {
        new Tween(this, "_container.position.x", newSpot, 10, true);
      }
    }
    moveRight() {
      var dtLeftX = this._container.position.x;
      var newSpot = (dtLeftX + 45);
      var maxLeftX = (GameStage.renderer.width / 2) + 150;
      var playerHalfWidth = this._body.width / 2;

      if (newSpot >= maxLeftX) {
        var newmaxLeft = maxLeftX - playerHalfWidth;
        new Tween(this, "_container.position.x", newmaxLeft, 10, true);
      } else {
        new Tween(this, "_container.position.x", newSpot, 10, true);
      }
    }
    moveUp() {
      var dtLeftY = this._container.position.y;
      var newSpot = (dtLeftY - 25);
      new Tween(this, "_container.position.y", this._originalY, 10, true);
    }
    moveDown() {
      var dtLeftY = this._container.position.y;
      var newSpot = (dtLeftY + 25);
      var orig = (this._originalY + 25);
      new Tween(this, "_container.position.y", orig, 10, true);
    }
    stan() {
      this._container.removeChild(this._body);
      this._body = PIXI.Sprite.fromImage('Character_Standing.png');
      this._container.addChild(this._body);
    }
    duck() {
      this._container.removeChild(this._body);
      this._body = PIXI.Sprite.fromImage('Character_Duck.png');
      this._container.addChild(this._body);
    }
    jump() {
      this._container.removeChild(this._body);
      this._body = PIXI.Sprite.fromImage('Character_Jump.png');
      this._container.addChild(this._body);
    }
    remove() {
      this._game.stage.removeChild(this._container);
    }
  }
  //GAME
  //
  //class Game extends EventEmitter{
  class Game {
    constructor(element) {
      this._element = element;
      this.person = null;
      this.Bullets = null;
      this.stage = new PIXI.Container();
      this.renderer = PIXI.autoDetectRenderer(300, 185);
      this._element.appendChild(this.renderer.view);
      this._lastFrameTime = 0;
      this.bulletArray = [];
      this.state = "";
      this.hitPoints = 5;
      requestAnimationFrame(this._tick.bind(this));
    }
    addBg() {
      var bg = new PIXI.Sprite.fromImage('Landscape.png');
      bg.anchor.set(0.5);
      bg.position.set(GameStage.renderer.view.width / 2, GameStage.renderer.view.height / 2);
      bg.scale.x = 1;
      bg.scale.y = 1;
      this.stage.addChild(bg);
    }
    addBullets() {
      var x = 0;
      var y = 0;
      var numberOfBullets = 3;
      for (let i = 0; i < numberOfBullets; i++) {
        if (this.bulletArray.length < numberOfBullets) {
          this.Bullets = new Bullets(this);
          this.Bullets.render();
        }
      }
    }
    addPerson() {
      let x = GameStage.renderer.width / 2;
      let y = GameStage.renderer.height / 2;
      this.person = new Person(this, x, y);
    }
    addState() {
      this.state = new State(this);
    }
    clear() {
      console.log('cleared');
      this.bulletArray = [];
      //Remove Everything in menu state
      this.Bullets.remove();
    }
    removePlayer() {
      this.person = null
    }
    reset() {
      console.log('reset');
      this.bulletArray = [];
      //Remove Everything in menu state
      this.Bullets.remove();
      this.person.remove();
      this.stage.removeChildren();
      //remove Container
    }

    _tick(currentTime) {
      this._lastFrameTime = currentTime;
    //  console.log(currentTime);
      this.renderer.render(this.stage);
      Tween.runTweens();
      requestAnimationFrame(this._tick.bind(this));
      this.Bullets.rain();
      this.Bullets.testCollision();
    }
  }

  //  STATES
var healthContainerIndex = 0;
var healthText;
  var bootState = {
    preload: function() {
      //Load assets
      this._assetLoader = new PIXI.loaders.Loader();
      this._assetLoader.add('Character_Duck.png');
      this._assetLoader.add('Character_Standing.png');
      this._assetLoader.add('Character_Jump.png');
      this._assetLoader.add('Landscape.png');
      this._assetLoader.add('bullet1.png');
      this._assetLoader.add('bullet2.png');
      this._assetLoader.add('bullet3.png');
      this._assetLoader.add('baddie1.gif');
      this._assetLoader.add('baddie2.gif');
      this._assetLoader.add('baddie3.gif');
      this._assetLoader.add('end.png');
      console.log('bootstate preloading');
      this.create();
    },
    create: function() {
      GameStage.addBg();
      GameStage.addPerson();
      GameStage.addBullets();
      let healthContainer = new PIXI.Container();
      healthText = new PIXI.Text('Clout: ' + GameStage.hitPoints, { display: 'block',  width: '100%', font: 'bold 15px Arial', fill: '#ffffff', align: 'center', strokeThickness: 1 });
      healthContainer.addChild(healthText);
      GameStage.stage.addChild(healthContainer);
      healthContainerIndex = GameStage.stage.children.indexOf(healthContainer);
    },
    update: function(hitPoints) {
      healthText.setText('Clout: ' + GameStage.hitPoints);

      if ( GameStage.hitPoints == 0)
        {
         GameStage.state.add("loose", looseState);
        }
      else {
        //GameStage.state.add("win", winState);
      }

    }
  }
  var looseState = {
    create: function() {
      //console.log('sry ur no longer relevant :()//');
      let container = new PIXI.Container();
      let endImg = new PIXI.Sprite.fromImage('end.png');
      endImg.anchor.set(0.5);
      endImg.position.set(GameStage.renderer.view.width / 2, GameStage.renderer.view.height / 2);
      endImg.scale.x = 0.4;
      endImg.scale.y = 0.4;
      endImg.alpha = 0.5;
      container.addChild(endImg);

       var spinningText = new PIXI.Text('sry ur no longer \n relevant :(', { font: 'bold 30px Arial', fill: '#ffffff', align: 'center', strokeThickness: 1 });
       container.addChild(spinningText);

       GameStage.clear();

       //RESTTART BUTTON
       let restartButton = new PIXI.Sprite.fromImage('end.png');
       restartButton.anchor.set(0.5);
       restartButton.interactive = true;
       restartButton.position.set(GameStage.renderer.view.width / 2, GameStage.renderer.view.height / 2);
       restartButton.scale.x = 0.1;
       restartButton.scale.y = 0.1;
       restartButton.alpha = 1;
       restartButton.on('click', function(e) {
         window.location.href = window.location.href;
        // GameStage.reset();
       });
       container.addChild(restartButton);
       GameStage.stage.addChild(container);

    },
    preload: function() {
      this.create();
    },
    update: function() {
    }
  }
  var menuState = {
    create: function() {
      console.log('in menu state');
      GameStage.reset();
      //create name input
      //Add new container
        //trigger play function with, call this.update
    },
    preload: function() {
      this.create();
    },
    update: function() {
      //call this
      //aka bootstate right now, needs to be swiched
      //GameStage.state.add("play", playState)
    }
  }
  var winState = {
    //TODO: wrap in event listener
    //GameStage.state.add(menu, menuSate);
    create: function() {

    },
    preload: function() {

    },
    update: function() {

    }
  }

  //  GAME State
  class State {
    constructor(game) {
      this._game = game;
      this._state = "";
      this._stateObj = {};
    }
    add(state, stateObj) {
      this._state = state;
      this._stateObj = stateObj;
      GameStage.state._stateObj.preload();
    }
  }



  //HELPER COLLISION DETECTION FUNCTION
  function hitTestRectangle(r1, r2) {

    //Define the variables we'll need to calculate
    let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

    //hit will determine whether there's a collision
    hit = false;
    //Find the center points of each sprite
    r1.centerX = r1.x + r1.width / 2;
    r1.centerY = r1.y + r1.height / 2;
    r2.centerX = r2.x + r2.width / 2;
    r2.centerY = r2.y + r2.height / 2;

    //console.log(r2);

    //Find the half-widths and half-heights of each sprite
    r1.halfWidth = r1.width / 2;
    r1.halfHeight = r1.height / 2;
    r2.halfWidth = r2.width / 2;
    r2.halfHeight = r2.height / 2;

    //Calculate the distance vector between the sprites
    vx = r1.centerX - r2.centerX;
    vy = r1.centerY - r2.centerY;

    //Figure out the combined half-widths and half-heights
    combinedHalfWidths = r1.halfWidth + r2.halfWidth;
    combinedHalfHeights = r1.halfHeight + r2.halfHeight;

    //Check for a collision on the x axis
    if (Math.abs(vx) < combinedHalfWidths) {

      //A collision might be occuring. Check for a collision on the y axis
      if (Math.abs(vy) < combinedHalfHeights) {

        //There's definitely a collision happening
        hit = true;
      } else {

        //There's no collision on the y axis
        hit = false;
      }
    } else {

      //There's no collision on the x axis
      hit = false;
    }

    //`hit` will be either `true` or `false`
    return hit;
  };

  //INIT
  let GameStage = new Game(document.body);
  GameStage.addState();
  GameStage.state.add("boot", bootState);

</script>
